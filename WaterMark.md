# Add Logo Watermark to Generated Mockup Images

## Overview

Add a logo watermark to mockup images after they're generated by Gemini/AI service. The watermark should be applied server-side before serving images to users.

## Requirements

- Local logo file (PNG with transparency recommended)
- Sharp library for image processing (Node.js)
- OR ImageSharp for ASP.NET implementation

## Logo File Setup

**Location:** Store logo in accessible path

- Next.js: `/public/watermark-logo.png`
- ASP.NET: `/wwwroot/images/watermark-logo.png`

**Logo Specifications:**

- Format: PNG with transparency
- Recommended size: 200-300px wide
- Consider having both light and dark versions for different backgrounds
- Keep it simple and recognizable at small sizes

## Implementation (Node.js with Sharp)

### Install Sharp

```bash
npm install sharp
```

### Watermark Function

```javascript
import sharp from "sharp";
import fetch from "node-fetch";
import path from "path";
import fs from "fs/promises";

/**
 * Add logo watermark to an image from a URL
 * @param {string} imageUrl - URL of the generated image from AI service
 * @param {object} options - Watermark options
 * @returns {Buffer} - Watermarked image buffer
 */
async function addLogoWatermark(imageUrl, options = {}) {
  const {
    logoPath = path.join(process.cwd(), "public", "watermark-logo.png"),
    logoWidth = 150,
    position = "southeast", // 'southeast', 'southwest', 'northeast', 'northwest', 'center'
    padding = 20, // pixels from edge
    opacity = 1.0, // 0.0 to 1.0
  } = options;

  try {
    // Download image from AI service
    const response = await fetch(imageUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.statusText}`);
    }
    const imageBuffer = await Buffer.from(await response.arrayBuffer());

    // Load and resize logo
    const logo = await sharp(logoPath).resize({ width: logoWidth }).toBuffer();

    // Get dimensions to calculate position if needed
    const imageMetadata = await sharp(imageBuffer).metadata();
    const logoMetadata = await sharp(logo).metadata();

    // Calculate position based on gravity and padding
    let compositeOptions = {
      input: logo,
      blend: "over",
    };

    if (position === "southeast") {
      compositeOptions.gravity = "southeast";
    } else if (position === "southwest") {
      compositeOptions.gravity = "southwest";
    } else if (position === "northeast") {
      compositeOptions.gravity = "northeast";
    } else if (position === "northwest") {
      compositeOptions.gravity = "northwest";
    } else if (position === "center") {
      compositeOptions.gravity = "center";
    } else {
      // Custom position with padding
      compositeOptions.top =
        imageMetadata.height - logoMetadata.height - padding;
      compositeOptions.left =
        imageMetadata.width - logoMetadata.width - padding;
    }

    // Apply watermark
    const watermarked = await sharp(imageBuffer)
      .composite([compositeOptions])
      .toBuffer();

    return watermarked;
  } catch (error) {
    console.error("Watermark error:", error);
    throw new Error(`Failed to add watermark: ${error.message}`);
  }
}
```

### Integration with API Route

```javascript
// /api/generate-mockup route or similar

export async function POST(request) {
  try {
    // ... your existing code to generate mockup with AI ...

    // Example: After Gemini/Stability AI returns image URL
    const generatedImageUrl = aiResponse.imageUrl;

    // Add watermark
    const watermarkedBuffer = await addLogoWatermark(generatedImageUrl, {
      logoWidth: 150,
      position: "southeast",
      padding: 20,
    });

    // Save watermarked image
    const filename = `mockup-${Date.now()}.png`;
    const outputPath = path.join(
      process.cwd(),
      "public",
      "generated",
      filename
    );

    // Ensure directory exists
    await fs.mkdir(path.dirname(outputPath), { recursive: true });

    // Write file
    await fs.writeFile(outputPath, watermarkedBuffer);

    // Return URL to watermarked image
    return Response.json({
      success: true,
      imageUrl: `/generated/${filename}`,
    });
  } catch (error) {
    console.error("Generation error:", error);
    return Response.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

### Alternative: Apply Watermark to Already-Downloaded Image

```javascript
/**
 * Add watermark to local image file
 * @param {string} inputPath - Path to input image
 * @param {string} outputPath - Path to save watermarked image
 */
async function watermarkLocalFile(inputPath, outputPath, options = {}) {
  const {
    logoPath = path.join(process.cwd(), "public", "watermark-logo.png"),
    logoWidth = 150,
    position = "southeast",
  } = options;

  const logo = await sharp(logoPath).resize({ width: logoWidth }).toBuffer();

  await sharp(inputPath)
    .composite([
      {
        input: logo,
        gravity: position,
        blend: "over",
      },
    ])
    .toFile(outputPath);

  return outputPath;
}

// Usage
await watermarkLocalFile(
  "/path/to/generated-mockup.png",
  "/path/to/watermarked-mockup.png"
);
```

## Implementation (ASP.NET with ImageSharp)

### Install ImageSharp

```bash
dotnet add package SixLabors.ImageSharp
dotnet add package SixLabors.ImageSharp.Drawing
```

### Watermark Service

```csharp
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Processing;
using SixLabors.ImageSharp.PixelFormats;

public class WatermarkService
{
    private readonly string _logoPath;
    private readonly ILogger<WatermarkService> _logger;

    public WatermarkService(IWebHostEnvironment env, ILogger<WatermarkService> logger)
    {
        _logoPath = Path.Combine(env.WebRootPath, "images", "watermark-logo.png");
        _logger = logger;
    }

    public async Task<byte[]> AddWatermarkAsync(
        string imageUrl,
        int logoWidth = 150,
        string position = "southeast",
        int padding = 20)
    {
        try
        {
            // Download image from AI service
            using var httpClient = new HttpClient();
            var imageBytes = await httpClient.GetByteArrayAsync(imageUrl);

            using var image = Image.Load(imageBytes);
            using var logo = Image.Load(_logoPath);

            // Resize logo
            logo.Mutate(x => x.Resize(logoWidth, 0));

            // Calculate position
            Point logoPosition = CalculatePosition(
                image.Width,
                image.Height,
                logo.Width,
                logo.Height,
                position,
                padding
            );

            // Apply watermark
            image.Mutate(ctx => ctx.DrawImage(
                logo,
                logoPosition,
                1f // opacity
            ));

            // Convert to byte array
            using var ms = new MemoryStream();
            await image.SaveAsPngAsync(ms);
            return ms.ToArray();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to add watermark");
            throw;
        }
    }

    private Point CalculatePosition(
        int imageWidth,
        int imageHeight,
        int logoWidth,
        int logoHeight,
        string position,
        int padding)
    {
        return position.ToLower() switch
        {
            "southeast" => new Point(
                imageWidth - logoWidth - padding,
                imageHeight - logoHeight - padding
            ),
            "southwest" => new Point(
                padding,
                imageHeight - logoHeight - padding
            ),
            "northeast" => new Point(
                imageWidth - logoWidth - padding,
                padding
            ),
            "northwest" => new Point(
                padding,
                padding
            ),
            "center" => new Point(
                (imageWidth - logoWidth) / 2,
                (imageHeight - logoHeight) / 2
            ),
            _ => new Point(
                imageWidth - logoWidth - padding,
                imageHeight - logoHeight - padding
            )
        };
    }
}
```

### Controller Integration

```csharp
[ApiController]
[Route("api/[controller]")]
public class MockupController : ControllerBase
{
    private readonly WatermarkService _watermarkService;
    private readonly IWebHostEnvironment _env;

    public MockupController(WatermarkService watermarkService, IWebHostEnvironment env)
    {
        _watermarkService = watermarkService;
        _env = env;
    }

    [HttpPost("generate")]
    public async Task<IActionResult> GenerateMockup([FromBody] MockupRequest request)
    {
        try
        {
            // ... your existing code to generate mockup with AI ...

            string generatedImageUrl = aiResponse.ImageUrl;

            // Add watermark
            var watermarkedBytes = await _watermarkService.AddWatermarkAsync(
                generatedImageUrl,
                logoWidth: 150,
                position: "southeast",
                padding: 20
            );

            // Save watermarked image
            var filename = $"mockup-{Guid.NewGuid()}.png";
            var outputPath = Path.Combine(_env.WebRootPath, "generated", filename);

            Directory.CreateDirectory(Path.GetDirectoryName(outputPath));
            await System.IO.File.WriteAllBytesAsync(outputPath, watermarkedBytes);

            return Ok(new {
                success = true,
                imageUrl = $"/generated/{filename}"
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { success = false, error = ex.Message });
        }
    }
}
```

## Caching Considerations

**Should you cache watermarked images?**

Yes, watermarked images should be cached to avoid re-processing:

```javascript
// Cache key example
const cacheKey = `${artworkHash}-${sceneId}-watermarked`;

// Check cache first
const cached = await getCachedImage(cacheKey);
if (cached) {
  return cached;
}

// Generate, watermark, then cache
const generated = await generateMockup(artwork, scene);
const watermarked = await addLogoWatermark(generated);
await cacheImage(cacheKey, watermarked);
```

**Database cache table:**

```sql
-- Add column to existing Mockups table
ALTER TABLE Mockups ADD WatermarkedImageUrl NVARCHAR(500);

-- Or create separate watermarked images table
CREATE TABLE WatermarkedMockups (
    Id UNIQUEIDENTIFIER PRIMARY KEY,
    OriginalMockupId UNIQUEIDENTIFIER NOT NULL,
    WatermarkedImageUrl NVARCHAR(500) NOT NULL,
    CreatedAt DATETIME NOT NULL,
    FOREIGN KEY (OriginalMockupId) REFERENCES Mockups(Id)
);
```

## Testing

### Test Script (Node.js)

```javascript
import { addLogoWatermark } from "./watermark.js";
import fs from "fs/promises";

async function testWatermark() {
  // Test with a sample generated image URL
  const testImageUrl = "https://example.com/generated-mockup.png";

  try {
    const watermarked = await addLogoWatermark(testImageUrl, {
      logoWidth: 150,
      position: "southeast",
      padding: 20,
    });

    // Save test output
    await fs.writeFile("test-watermarked.png", watermarked);
    console.log("✓ Watermark test successful");
  } catch (error) {
    console.error("✗ Watermark test failed:", error);
  }
}

testWatermark();
```

### Manual Testing Checklist

- [ ] Logo loads correctly from file path
- [ ] Logo is properly sized (not too large or small)
- [ ] Logo is positioned correctly (southeast, southwest, etc.)
- [ ] Logo has proper transparency/blending
- [ ] Watermark doesn't obscure important label content
- [ ] Works with different image sizes (1024x1024, etc.)
- [ ] Performance is acceptable (<1 second for watermarking)
- [ ] Error handling works (missing logo file, invalid image URL)

## Position Options Reference

```javascript
// Common positions
const positions = {
  southeast: "Bottom-right corner (most common)",
  southwest: "Bottom-left corner",
  northeast: "Top-right corner",
  northwest: "Top-left corner",
  center: "Center of image (prominent watermark)",
};
```

## Logo Design Tips

**For best results:**

- Use PNG with transparent background
- Logo should be simple and recognizable at small sizes
- Consider a semi-transparent white version for dark backgrounds
- Consider a semi-transparent black version for light backgrounds
- Test on various product mockups before finalizing

**Recommended sizes:**

- Small watermark: 100-150px wide
- Medium watermark: 150-200px wide
- Large watermark: 200-300px wide

## Performance Considerations

**Watermark processing time:**

- Typical: 200-500ms per image
- Acceptable for real-time generation

**Optimization tips:**

- Cache watermarked images aggressively
- Pre-resize logo once at startup (if using same size)
- Use Sharp's built-in optimization options

```javascript
// Pre-load and resize logo once
let resizedLogo;
async function initWatermark() {
  resizedLogo = await sharp("watermark-logo.png")
    .resize({ width: 150 })
    .toBuffer();
}

// Use pre-resized logo in watermark function
async function addWatermark(imageUrl) {
  // ... load image ...
  return sharp(imageBuffer)
    .composite([{ input: resizedLogo, gravity: "southeast" }])
    .toBuffer();
}
```

## Error Handling

```javascript
async function addWatermarkSafe(imageUrl) {
  try {
    return await addLogoWatermark(imageUrl);
  } catch (error) {
    console.error("Watermark failed:", error);

    // Fallback: return original image if watermark fails
    const response = await fetch(imageUrl);
    return Buffer.from(await response.arrayBuffer());
  }
}
```

## Environment Variables

Add to `.env.local` or `.env`:

```bash
# Watermark settings
WATERMARK_LOGO_PATH=/public/watermark-logo.png
WATERMARK_SIZE=150
WATERMARK_POSITION=southeast
WATERMARK_PADDING=20
```

## Production Checklist

- [ ] Logo file is committed to repository or CDN
- [ ] Watermark settings are configurable via environment variables
- [ ] Error handling includes fallback to non-watermarked image
- [ ] Performance is monitored (watermarking shouldn't add >1s)
- [ ] Cached images include watermark (don't re-watermark on cache hit)
- [ ] Logo is legally cleared for use
- [ ] Logo size is appropriate for 1024x1024 images
- [ ] Watermark position doesn't obscure product labels

## Next Steps

1. Add logo file to project
2. Install Sharp (Node.js) or ImageSharp (ASP.NET)
3. Implement watermark function
4. Integrate into existing mockup generation flow
5. Test with various product types
6. Deploy and monitor performance

---

**Questions to answer:**

- What logo size looks best? (Test 100px, 150px, 200px)
- Which position? (Recommend southeast/bottom-right)
- Should watermark be semi-transparent or fully opaque?
- Do you need different logos for light vs dark backgrounds?
